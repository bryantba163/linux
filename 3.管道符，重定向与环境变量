管道符，重定向与环境变量
1.输入输出重定向
  简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是把原本要输出到屏幕的数据信息写入指定文件中。日常工作中，使用输出重定向的频率更高，所以输出重定向分为：标准输出重定向和错误输出重定向两种。
  标准输入重定向(STDIN，文件描述符为0)：默认从键盘输入，也可以从其他命令中输入。
  标准输出重定向(STDOUT，文件描述符为1)：默认输出到屏幕。
  错误输出重定向(STDERR，文件描述符为2)：默认输出到屏幕。
  例如：我们分别查看两个文件的属性信息，其中第二个文件是不存在的，虽然针对这两个文件的操作都分别会输出一些信息在屏幕，但这两个操作的差异很大
  touch linuxprobe
  ll linuxprobe
  -rw-r--r-- . 1 root root 0 Mar 20 22:35 linuxprobe
  ll xxxxx
  ls:cannot access xxxxx: No such file or directory
  这两个命令中linuxprobe这个文件是存在的，输出信息是这个文件的权限，所有者，所属组，文件大小，修改时间等信息，这是ll命令的标准输出信息。而名为xxxxx这个文件是不存在的，所以执行完ll命令后显示的报错提示信息，是ll命令的错误输出信息。那么，要把原本输出到屏幕上的数据转而写入到文件中，就要区别对待这两种输出信息。
  输入重定向中用到的符号及其作用
  命令 < 文件   作用为将文件作为命令的标准输入
  命令 << 分界符  作用是从标准输入中读入，直到见到分界符才停止
  命令 < 文件1 > 文件2  作用是将文件1作为命令的标准输入并将标准输入到文件2
  对于输出重定向用到的符号及其作用：
  命令 > 文件 将标准输出重定向到一个文件中(清空原有文件的数据)
  命令 2> 文件 将错误输出重定向到一个文件中(清空原有文件中的数据)
  命令 >> 文件 将标准输出重定向到一个文件中(追加到原有内容的后面)
  命令 2>> 文件 将错误输出重定向到一个文件中(追加到原有内容后）
  命令 >> 文件 2> &1 或 命令 &>> 文件 将标准输出和错误输出共同写入到文件中(追加到原有内容后）
  对于重定向中的标准输出模式，可以省略文件描述符1不写，但是错误输出模式的文件描述符2是必须要写的。
  例：通过标准重定向将man bash 命令原本要输出到屏幕的信息写入到文件readme.txt中，然后显示readme.txt中的内容
  man bash > readme.txt
  cat readme.txt
  接下来尝试输出重定向技术中的覆盖写入与追加写入两个不同模式带来的变化。首先，通过覆盖写入模式(命令 > 文件)，向readme.txt中写入一行数据，然后再通过追加模式(命令 >> 文件)再向文件写入一行数据：
  echo "Welcome to ali.com"  > readme.txt
  echo "hello balin" >> readme.txt
  cat readme.txt
  输出为：Welcome to ali.com
         hello balin
  虽然都是输出重定向技术，但是不同命令的标准输出和错误输出还是有区别的，例如查看当前目录中某个文件的信息时，这里以linuxprobe为例，这个文件是真实存在的，因此使用标准输出即可将原本要输出到屏幕的信息写入到文件中，而错误的输出重定向则依然把信息输出到屏幕
  ll linuxprobe 
  -rw-r--r-- . 1 root root 0 Mar 20 23:17 linuxprobe
  ll linuxprobe > /root/stderr.txt
  ll linuxprobe 2> /root/stderr.txt
  -rw-r--r-- . 1 root root 0 Mar 20 23:17 linuxprobe
  如果想把命令的报错信息写入文件中，该怎么操作呢？当用户在执行一个自动化的shell脚本时，这个操作会很有用，因为它可以把整个脚本在执行过程中的报错信息记录到文件中，方便安装后的排错工作。例子以一个不存在的文件xxxxx来演示
  ll xxxxx
  cannot access xxxxx: No such file or directory
  ll xxxxx > /root/stderr.txt
  cannot access xxxxx: No such file or directory
  ll xxxxx 2> /root/stderr.txt
  cat /stderr.txt
  ls:cannot access xxxxx: No such file or directory
  输入重定向相对来说有些冷门，输入重定向的作用是把文件直接导入到命令中，例子中使用输入重定向把readme.txt 文件导入给wc -l命令，统计文件中的行数
  wc -l < readme.txt
  2
  这个命令其实等同于cat readme.txt | wc -l
2.管道命令符
  管到符执行格式为 命令A | 命令B ，作用可以概括为：把前一个命令原本要输出到屏幕的数据当作是后一个命令的标准输入。例如：使用grep搜索文本时，通过匹配关键词/sbin/nologin找出了所有被限制登陆系统的用户，使用管道符的话可以合并为一条：grep "/sbin/nologin" /etc/passwd | wc -l
  找出被限制登陆的用户命令是grep "/sbin/nologin" /etc/passwd
  统计文本的行数命令为wc -l
  管道符的作用很多，比如用翻页的形式查看/etc 目录中的文件列表及属性信息：ll /etc | more 
  在修改用户密码时，通常需要输入两次密码进行确认，这在写脚本时会成为致命缺陷，可以通过把管道符和passwd 命令的--stdin 参数结合，来实现用一条命令来完成密码重置的操作：echo "Balin19961030!" | passwd --stdin root
  比如在发送电子邮件时，默认采用交互式的方式来进行，完全可以利用一条结合了管道符的命令语句，把编辑好的内容和标题一起打包，最终用一条命令实现邮件的发送：echo "Content" | mail -s "Subject" balin
  登陆balin后查看/var/spool/mail/balin 可以看见这个邮件
  管道符在一个命令组合中可以多次使用，命令A | 命令B | 命令C
3.命令行的通配符
  例如查看/dev下的sda盘，目录少的时候容易查找，如果多的话，可以用通配符星号(*)来代表匹配零个或多个字符，问号(?)代表匹配单个字符，中括号内加数字[0-9]代表匹配0~9之间的单个数字的字符，而中括号内加上字母[abc]则代表匹配a，b，c，三个字符中的任意一个字符
  例子：匹配/dev下所有以vda开头的文件(因为用云主机做为实验机，没有sda盘，故用vda做)
  ll /dev/vda*
  输出vda与vda1
  如果只想查看vda开头，但是后面还紧跟其他某一个字符的文件的相关信息，可以使用？来通配
  ll /dev/vda？
  输出vda1
  除了使用[0-9]来匹配0~9之间的单个数字，也可以用[135]这种方式仅匹配这三个指定数字中的一个，如果没有匹配，则不会显示出来：
  ll /dev/vda[0-9]
  输出vda1
  ll /dev/vda[35]
  输出cannot find，因为只有vda和vda1
4.常用的转义字符
  四个最常用的转义字符
  反斜杠 \ ：使反斜杠后面的一个变量变为单纯的字符串
  单引号 " ：转义其中所有的变量为单纯的字符串
  双引号 ""：保留其中变量的属性，不进行转义处理
  反引号 ``：把其中的命令执行后返回结果
  例:先定义一个名为PRICE的变量并赋值为5，然后输出以双引号括起来的字符串与变量信息：
  PRICE=5
  echo "Price is $PRICE"
  输出Price is 5
  接下来，我们希望能够输出 Price is $5 ，即价格是5美元的字符串内容，但是美元的符号和变量提取符号合并后的$$的作用是显示当前程序的进程ID号码，于是执行命令后输出的并不是预期的
  echo "Price is $$PRICE"
  输出Price is 29530PRICE
  如果想让第一个 $ 作为美元的符号来输出，那么则需要反斜杠 \ 来进行转义，将这个命令提取符 $ 转义为单纯的文本
  echo "Prince is \$$PRICE"
  输出为：Price is $5
  而如果只需要某个命令的输出值时，可以像`命令` 这样，将命令使用反引号括起来，达到预期效果，比如，将反引号与uname -a结合，然后用echo来查看版本和内核
  echo `uname -a`
  Linux ali 4.18.0-147.5.1.el8_1.x86_64 #1 SMP Wed Feb 5 02:00:39 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux
5.环境变量
  变量 是计算机系统用来保存可变值的数据类型，在Linux中，变量名称一般为大写的，可以直接通过变量名称来提取到对应的变量值。
  Linux中一切皆文件，Linux命令也是文件，当在终端输入一条命令后，4个步骤执行：
  1）判断用户是否在以绝对路径或相对路径的方式输入命令(/bin/ls)，如果是则直接执行
  2）Linux系统检查输入的命令是否为别名命令，alias可以建立属于自己的别名命令，alias 别名=命令 即可，取消别名命令为 unalias 别名。如，rm命令 就是别名，alias rm=rm -i 为了防止勿删文件，特意加了-i选项
  3）Bash解释器判断输入的命令是内部命令还是外部命令。内部命令是Bash解释器内部的指令，会被bash直接执行，但是用户大部分输入的命令是外部命令，那么就会到第四步，type 命令可以查看某个命令是外部命令还是内部命令
  4）系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫PATH，可以理解为"解释器的助手"，作用是告诉Bash解释器待执行的命令可能存放的位置，然后Bash解释器在这些位置逐个查找。PATH是由多个路径值组成的变量，每个路径之间用冒号间隔，对PATH变量中路径的增加和删除，会影响到Bash解释器对Linux命令的查找
  比较经典的问题，为什么不能把当前目录(.)添加到PATH中，原因是，尽管添加当前目录到PATH变量，从而在某些情况下可以让用户免去输入命令所在路径的麻烦。但是，如果黑客在比较常用的公共目录如/tmp中存放了一个与ls或cd同名的木马文件，而用户恰巧在公共目录中执行了这些命令，那么很有可能被黑。
  env命令可以查看Linux中所有的环境变量，10个重要的环境变量如下：
  HOME变量 是用户的家目录
  SHELL变量 用户所在的shell解释器的名称
  HISTSIZE 输出历史命令记录的条数
  HISTFILESIZE 保存的历史命令记录的条数
  MAIL 邮件保存的路径
  LANG 系统语言的名称
  RANDOM 生成一个随机数字
  PS1 解释器的提示符
  PATH 定义解释器搜索用户执行命令的路径
  EDITOR 用户默认的文本编辑器
  变量是由固定的变量名与用户或系统设置的变量值两部分组成的，也可以自己建变量，比如建立一个为BALIN的变量，路径为/home/bali
  直接cd $BALIN直接进入/home/balin目录，但是这样的变量不具有全局性，作用范围有限，默认情况下不能被其他用户使用，可以使用export命令将其提升为全局变量